package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"os/exec"
	"runtime"
	"strings"

	"github.com/rogpeppe/go-internal/imports"
)

var (
	tags = map[string]bool{
		runtime.GOOS:   true,
		runtime.GOARCH: true,
	}
)

func main() {
	os.Exit(main1())
}

func main1() int {
	switch err := mainerr(); err {
	case nil:
		return 0
	case flag.ErrHelp:
		return 2
	default:
		fmt.Fprintln(os.Stderr, err)
		return 1
	}
}

// TODO take into account build tags more explicitly

func mainerr() (retErr error) {
	fs := flag.NewFlagSet(os.Args[0], flag.ContinueOnError)
	fs.Usage = func() {
		mainUsage(os.Stderr)
	}
	if err := fs.Parse(os.Args[1:]); err != nil {
		return err
	}

	if len(flag.Args()) > 0 {
		return fmt.Errorf("helpflagtopkgdoc takes no arguments")
	}

	pkg := os.Getenv("GOPACKAGE")
	if pkg != "main" {
		return fmt.Errorf("helpflagtopkgdoc can only be used with main packages")
	}

	run := exec.Command("gobin", "-m", "-run", ".", "-help")
	out, err := run.CombinedOutput()
	// it's go convention to exit with code 2 for help information
	if ee, ok := err.(*exec.ExitError); !ok || ExitCode(ee.ProcessState) != 2 {
		return fmt.Errorf("failed to run %v: %v\n%s", strings.Join(run.Args, " "), err, out)
	}

	helpOut := string(out)
	helpOut = strings.TrimRight(helpOut, "\n")

	var pkgDoc string
	pkgDoc += "// Code generated by helpflagtopkgdoc. DO NOT EDIT.\n"
	pkgDoc += "\n"
	pkgDoc += "// " + strings.Replace(helpOut, "\n", "\n// ", -1) + "\n"
	pkgDoc += "package main\n"

	pkgDoc = strings.Replace(pkgDoc, "\n// \n", "\n//\n", -1)

	fn := "gen_helpflagtopkgdoc.go"

	if err := ioutil.WriteFile(fn, []byte(pkgDoc), 0666); err != nil {
		return fmt.Errorf("failed to write %v: %v\n", fn, err)
	}

	// we can't check the output with go doc, because it does some formatting
	// on the output. Instead, we build up an unformatted version by iterating
	// over the

	// check that the pkg doc we wrote is the only doc present
	doc, err := parsePkgDocs(pkg)
	if err != nil {
		return fmt.Errorf("failed to check package doc: %v", err)
	}

	got := doc
	want := helpOut + "\n"
	if got != want {
		return fmt.Errorf("written output differs from actual go doc:\n%v", Diff(want, got))
	}

	return nil
}

func parsePkgDocs(pkgName string) (string, error) {
	filterFn := func(fi os.FileInfo) bool {
		return imports.MatchFile(fi.Name(), tags)
	}

	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, ".", filterFn, parser.PackageClauseOnly|parser.ParseComments)
	if err != nil {
		return "", fmt.Errorf("could not run ParseDir: %v", err)
	}

	pkg, ok := pkgs[pkgName]
	if !ok {
		return "", fmt.Errorf("failed to parse pacakge %v", pkgName)
	}

	var comm strings.Builder
	var sep string

	for _, f := range pkg.Files {
		var comments bytes.Buffer
		for _, cg := range f.Comments {
			if cg == f.Doc || cg.Pos() > f.Package {
				break
			}
			for _, cm := range cg.List {
				comments.WriteString(cm.Text + "\n")
			}
			comments.WriteString("\n")
		}
		if !imports.ShouldBuild(comments.Bytes(), tags) {
			continue
		}
		if f.Doc == nil || len(f.Doc.List) == 0 {
			continue
		}

		comm.WriteString(sep)
		comm.WriteString(f.Doc.Text())
		sep = "\n"
	}

	return comm.String(), nil
}

func Diff(text1, text2 string) string {
	if text1 != "" && !strings.HasSuffix(text1, "\n") {
		text1 += "(missing final newline)"
	}
	lines1 := strings.Split(text1, "\n")
	lines1 = lines1[:len(lines1)-1] // remove empty string after final line
	if text2 != "" && !strings.HasSuffix(text2, "\n") {
		text2 += "(missing final newline)"
	}
	lines2 := strings.Split(text2, "\n")
	lines2 = lines2[:len(lines2)-1] // remove empty string after final line

	// Naive dynamic programming algorithm for edit distance.
	// https://en.wikipedia.org/wiki/Wagnerâ€“Fischer_algorithm
	// dist[i][j] = edit distance between lines1[:len(lines1)-i] and lines2[:len(lines2)-j]
	// (The reversed indices make following the minimum cost path
	// visit lines in the same order as in the text.)
	dist := make([][]int, len(lines1)+1)
	for i := range dist {
		dist[i] = make([]int, len(lines2)+1)
		if i == 0 {
			for j := range dist[0] {
				dist[0][j] = j
			}
			continue
		}
		for j := range dist[i] {
			if j == 0 {
				dist[i][0] = i
				continue
			}
			cost := dist[i][j-1] + 1
			if cost > dist[i-1][j]+1 {
				cost = dist[i-1][j] + 1
			}
			if lines1[len(lines1)-i] == lines2[len(lines2)-j] {
				if cost > dist[i-1][j-1] {
					cost = dist[i-1][j-1]
				}
			}
			dist[i][j] = cost
		}
	}

	var buf strings.Builder
	i, j := len(lines1), len(lines2)
	for i > 0 || j > 0 {
		cost := dist[i][j]
		if i > 0 && j > 0 && cost == dist[i-1][j-1] && lines1[len(lines1)-i] == lines2[len(lines2)-j] {
			fmt.Fprintf(&buf, " %s\n", lines1[len(lines1)-i])
			i--
			j--
		} else if i > 0 && cost == dist[i-1][j]+1 {
			fmt.Fprintf(&buf, "-%s\n", lines1[len(lines1)-i])
			i--
		} else {
			fmt.Fprintf(&buf, "+%s\n", lines2[len(lines2)-j])
			j--
		}
	}
	return buf.String()
}
