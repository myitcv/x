// Code generated by immutableGen. DO NOT EDIT.

package immtodoapp

//immutableVet:skipFile

import (
	"myitcv.io/immutable"
)

//
// itemS is an immutable type and has the following template:
//
// 	[]*item
//
type itemS struct {
	theSlice []*item
	mutable  bool
	__tmpl   _Imm_itemS
}

var _ immutable.Immutable = new(itemS)
var _ = new(itemS).__tmpl

func newItemS(s ...*item) *itemS {
	c := make([]*item, len(s))
	copy(c, s)

	return &itemS{
		theSlice: c,
	}
}

func newItemSLen(l int) *itemS {
	c := make([]*item, l)

	return &itemS{
		theSlice: c,
	}
}

func (m *itemS) Mutable() bool {
	return m.mutable
}

func (m *itemS) Len() int {
	if m == nil {
		return 0
	}

	return len(m.theSlice)
}

func (m *itemS) Get(i int) *item {
	return m.theSlice[i]
}

func (m *itemS) AsMutable() *itemS {
	if m == nil {
		return nil
	}

	if m.Mutable() {
		return m
	}

	res := m.dup()
	res.mutable = true

	return res
}

func (m *itemS) dup() *itemS {
	resSlice := make([]*item, len(m.theSlice))

	for i := range m.theSlice {
		resSlice[i] = m.theSlice[i]
	}

	res := &itemS{
		theSlice: resSlice,
	}

	return res
}

func (m *itemS) AsImmutable(v *itemS) *itemS {
	if m == nil {
		return nil
	}

	if v == m {
		return m
	}

	m.mutable = false
	return m
}

func (m *itemS) Range() []*item {
	if m == nil {
		return nil
	}

	return m.theSlice
}

func (m *itemS) WithMutable(f func(mi *itemS)) *itemS {
	res := m.AsMutable()
	f(res)
	res = res.AsImmutable(m)

	return res
}

func (m *itemS) WithImmutable(f func(mi *itemS)) *itemS {
	prev := m.mutable
	m.mutable = false
	f(m)
	m.mutable = prev

	return m
}

func (m *itemS) Set(i int, v *item) *itemS {
	if m.mutable {
		m.theSlice[i] = v
		return m
	}

	res := m.dup()
	res.theSlice[i] = v

	return res
}

func (m *itemS) Append(v ...*item) *itemS {
	if m.mutable {
		m.theSlice = append(m.theSlice, v...)
		return m
	}

	res := m.dup()
	res.theSlice = append(res.theSlice, v...)

	return res
}
func (s *itemS) IsDeeplyNonMutable(seen map[interface{}]bool) bool {
	if s == nil {
		return true
	}

	if s.Mutable() {
		return false
	}
	if s.Len() == 0 {
		return true
	}

	if seen == nil {
		return s.IsDeeplyNonMutable(make(map[interface{}]bool))
	}

	if seen[s] {
		return true
	}

	seen[s] = true

	for _, v := range s.theSlice {
		if v != nil && !v.IsDeeplyNonMutable(seen) {
			return false
		}
	}
	return true
}

//
// item is an immutable type and has the following template:
//
// 	struct {
// 		name string
// 	}
//
type item struct {
	_name string

	mutable bool
	__tmpl  _Imm_item
}

var _ immutable.Immutable = new(item)
var _ = new(item).__tmpl

func (s *item) AsMutable() *item {
	if s.Mutable() {
		return s
	}

	res := *s
	res.mutable = true
	return &res
}

func (s *item) AsImmutable(v *item) *item {
	if s == nil {
		return nil
	}

	if s == v {
		return s
	}

	s.mutable = false
	return s
}

func (s *item) Mutable() bool {
	return s.mutable
}

func (s *item) WithMutable(f func(si *item)) *item {
	res := s.AsMutable()
	f(res)
	res = res.AsImmutable(s)

	return res
}

func (s *item) WithImmutable(f func(si *item)) *item {
	prev := s.mutable
	s.mutable = false
	f(s)
	s.mutable = prev

	return s
}
func (s *item) IsDeeplyNonMutable(seen map[interface{}]bool) bool {
	if s == nil {
		return true
	}

	if s.Mutable() {
		return false
	}

	if seen == nil {
		return s.IsDeeplyNonMutable(make(map[interface{}]bool))
	}

	if seen[s] {
		return true
	}

	seen[s] = true
	return true
}
func (s *item) name() string {
	return s._name
}

// setName is the setter for Name()
func (s *item) setName(n string) *item {
	if s.mutable {
		s._name = n
		return s
	}

	res := *s
	res._name = n
	return &res
}
