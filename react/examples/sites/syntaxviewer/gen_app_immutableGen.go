// Code generated by immutableGen. DO NOT EDIT.

package main

//immutableVet:skipFile

import (
	"myitcv.io/immutable"
)

//
// langState is an immutable type and has the following template:
//
// 	struct {
// 		Code	string
// 		Ast	string
// 		Error	bool
// 	}
//
type langState struct {
	_Code  string
	_Ast   string
	_Error bool

	mutable bool
	__tmpl  _Imm_langState
}

var _ immutable.Immutable = new(langState)
var _ = new(langState).__tmpl

func (s *langState) AsMutable() *langState {
	if s.Mutable() {
		return s
	}

	res := *s
	res.mutable = true
	return &res
}

func (s *langState) AsImmutable(v *langState) *langState {
	if s == nil {
		return nil
	}

	if s == v {
		return s
	}

	s.mutable = false
	return s
}

func (s *langState) Mutable() bool {
	return s.mutable
}

func (s *langState) WithMutable(f func(si *langState)) *langState {
	res := s.AsMutable()
	f(res)
	res = res.AsImmutable(s)

	return res
}

func (s *langState) WithImmutable(f func(si *langState)) *langState {
	prev := s.mutable
	s.mutable = false
	f(s)
	s.mutable = prev

	return s
}
func (s *langState) IsDeeplyNonMutable(seen map[interface{}]bool) bool {
	if s == nil {
		return true
	}

	if s.Mutable() {
		return false
	}

	if seen == nil {
		return s.IsDeeplyNonMutable(make(map[interface{}]bool))
	}

	if seen[s] {
		return true
	}

	seen[s] = true
	return true
}
func (s *langState) Code() string {
	return s._Code
}

// SetCode is the setter for Code()
func (s *langState) SetCode(n string) *langState {
	if s.mutable {
		s._Code = n
		return s
	}

	res := *s
	res._Code = n
	return &res
}
func (s *langState) Ast() string {
	return s._Ast
}

// SetAst is the setter for Ast()
func (s *langState) SetAst(n string) *langState {
	if s.mutable {
		s._Ast = n
		return s
	}

	res := *s
	res._Ast = n
	return &res
}
func (s *langState) Error() bool {
	return s._Error
}

// SetError is the setter for Error()
func (s *langState) SetError(n bool) *langState {
	if s.mutable {
		s._Error = n
		return s
	}

	res := *s
	res._Error = n
	return &res
}
