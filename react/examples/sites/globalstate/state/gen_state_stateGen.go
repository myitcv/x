// Code generated by stateGen; DO NOT EDIT.

package state

import (
	"errors"
	"path"
	"strings"

	"myitcv.io/react/examples/sites/globalstate/model"
)

var _ Node = new(App)

type App struct {
	*rootNode
	prefix string

	_Root          *Data
	_CurrentPerson *ModelPersonPLeaf
}

func newApp(r *rootNode, prefix string) *App {
	prefix = path.Join(prefix, "App")

	res := &App{
		rootNode: r,
		prefix:   prefix,
	}
	res._Root = newData(r, prefix)
	res._CurrentPerson = newModelPersonPLeaf(r, prefix)
	return res
}

func (n *App) Subscribe(cb func()) *Sub {
	return n.rootNode.subscribe(n.prefix, cb)
}
func (n *App) Root() *Data {
	return n._Root
}
func (n *App) CurrentPerson() *ModelPersonPLeaf {
	return n._CurrentPerson
}

var _ Node = new(Data)

type Data struct {
	*rootNode
	prefix string

	_People *ModelPeoplePLeaf
}

func newData(r *rootNode, prefix string) *Data {
	prefix = path.Join(prefix, "Data")

	res := &Data{
		rootNode: r,
		prefix:   prefix,
	}
	res._People = newModelPeoplePLeaf(r, prefix)
	return res
}

func (n *Data) Subscribe(cb func()) *Sub {
	return n.rootNode.subscribe(n.prefix, cb)
}
func (n *Data) People() *ModelPeoplePLeaf {
	return n._People
}

type ModelPersonPLeaf struct {
	*rootNode
	prefix string
}

var _ Node = new(ModelPersonPLeaf)

func newModelPersonPLeaf(r *rootNode, prefix string) *ModelPersonPLeaf {
	prefix = path.Join(prefix, "ModelPersonPLeaf")

	return &ModelPersonPLeaf{
		rootNode: r,
		prefix:   prefix,
	}
}

func (m *ModelPersonPLeaf) Get() *model.Person {
	var res *model.Person
	if v, ok := m.rootNode.get(m.prefix); ok {
		return v.(*model.Person)
	}
	return res
}

func (m *ModelPersonPLeaf) Set(v *model.Person) {
	m.rootNode.set(m.prefix, v)
}

func (m *ModelPersonPLeaf) Subscribe(cb func()) *Sub {
	return m.rootNode.subscribe(m.prefix, cb)
}

type ModelPeoplePLeaf struct {
	*rootNode
	prefix string
}

var _ Node = new(ModelPeoplePLeaf)

func newModelPeoplePLeaf(r *rootNode, prefix string) *ModelPeoplePLeaf {
	prefix = path.Join(prefix, "ModelPeoplePLeaf")

	return &ModelPeoplePLeaf{
		rootNode: r,
		prefix:   prefix,
	}
}

func (m *ModelPeoplePLeaf) Get() *model.People {
	var res *model.People
	if v, ok := m.rootNode.get(m.prefix); ok {
		return v.(*model.People)
	}
	return res
}

func (m *ModelPeoplePLeaf) Set(v *model.People) {
	m.rootNode.set(m.prefix, v)
}

func (m *ModelPeoplePLeaf) Subscribe(cb func()) *Sub {
	return m.rootNode.subscribe(m.prefix, cb)
}
func NewRoot() *App {
	r := &rootNode{
		store: make(map[string]interface{}),
		cbs:   make(map[string]map[*Sub]struct{}),
		subs:  make(map[*Sub]struct{}),
	}

	return newApp(r, "")
}

type Node interface {
	Subscribe(cb func()) *Sub
}

type Sub struct {
	*rootNode
	prefix string
	cb     func()
}

func (s *Sub) Clear() {
	s.rootNode.unsubscribe(s)
}

var NoSuchSubErr = errors.New("No such sub")

type rootNode struct {
	store map[string]interface{}
	cbs   map[string]map[*Sub]struct{}
	subs  map[*Sub]struct{}
}

func (r *rootNode) subscribe(prefix string, cb func()) *Sub {

	res := &Sub{
		cb:       cb,
		prefix:   prefix,
		rootNode: r,
	}

	l, ok := r.cbs[prefix]
	if !ok {
		l = make(map[*Sub]struct{})
		r.cbs[prefix] = l
	}

	l[res] = struct{}{}
	r.subs[res] = struct{}{}

	return res
}

func (r *rootNode) unsubscribe(s *Sub) {
	if _, ok := r.subs[s]; !ok {
		panic(NoSuchSubErr)
	}

	l, ok := r.cbs[s.prefix]
	if !ok {
		panic("Real problems...")
	}

	delete(l, s)
	delete(r.subs, s)
}

func (r *rootNode) get(k string) (interface{}, bool) {
	v, ok := r.store[k]
	return v, ok
}

func (r rootNode) set(k string, v interface{}) {
	if curr, ok := r.store[k]; ok && v == curr {
		return
	}

	r.store[k] = v

	parts := strings.Split(k, "/")

	var subs []*Sub

	var kk string

	for _, p := range parts {
		kk = path.Join(kk, p)

		if ll, ok := r.cbs[kk]; ok {
			for k := range ll {
				subs = append(subs, k)
			}
		}

	}

	for _, s := range subs {
		s.cb()
	}
}
