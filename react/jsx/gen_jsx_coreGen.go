// Code generated by coreGen. DO NOT EDIT.

package jsx

import (
	"fmt"
	"strings"

	"myitcv.io/react"

	"golang.org/x/net/html"
)

func parse(n *html.Node) react.Element {
	switch n.Type {
	case html.TextNode:
		return react.S(n.Data)
	case html.ElementNode:
		// we will fall out from here...
	default:
		panic(fmt.Errorf("cannot handle NodeType %v", n.Type))
	}

	switch n.Data {

	case "a":
		return parseA(n)

	case "abbr":
		return parseAbbr(n)

	case "article":
		return parseArticle(n)

	case "aside":
		return parseAside(n)

	case "b":
		return parseB(n)

	case "br":
		return parseBr(n)

	case "button":
		return parseButton(n)

	case "caption":
		return parseCaption(n)

	case "code":
		return parseCode(n)

	case "div":
		return parseDiv(n)

	case "em":
		return parseEm(n)

	case "footer":
		return parseFooter(n)

	case "form":
		return parseForm(n)

	case "h1":
		return parseH1(n)

	case "h2":
		return parseH2(n)

	case "h3":
		return parseH3(n)

	case "h4":
		return parseH4(n)

	case "h5":
		return parseH5(n)

	case "h6":
		return parseH6(n)

	case "header":
		return parseHeader(n)

	case "hr":
		return parseHr(n)

	case "i":
		return parseI(n)

	case "iframe":
		return parseIFrame(n)

	case "img":
		return parseImg(n)

	case "input":
		return parseInput(n)

	case "label":
		return parseLabel(n)

	case "li":
		return parseLi(n)

	case "main":
		return parseMain(n)

	case "nav":
		return parseNav(n)

	case "option":
		return parseOption(n)

	case "p":
		return parseP(n)

	case "pre":
		return parsePre(n)

	case "select":
		return parseSelect(n)

	case "span":
		return parseSpan(n)

	case "s":
		return parseStrike(n)

	case "sup":
		return parseSup(n)

	case "table":
		return parseTable(n)

	case "tbody":
		return parseTbody(n)

	case "td":
		return parseTd(n)

	case "textarea":
		return parseTextArea(n)

	case "th":
		return parseTh(n)

	case "thead":
		return parseThead(n)

	case "tr":
		return parseTr(n)

	case "ul":
		return parseUl(n)

	default:
		panic(fmt.Errorf("cannot handle Element %v", n.Data))
	}
}
func parseA(n *html.Node) *react.AElem {

	var kids []react.Element

	var vp *react.AProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.AProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "href":
				vp.Href = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case v == "target":
				vp.Target = a.Val

			case v == "title":
				vp.Title = a.Val

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <a> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.A(vp, kids...)

}
func parseAbbr(n *html.Node) *react.AbbrElem {

	var kids []react.Element

	var vp *react.AbbrProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.AbbrProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <abbr> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Abbr(vp, kids...)

}
func parseArticle(n *html.Node) *react.ArticleElem {

	var kids []react.Element

	var vp *react.ArticleProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.ArticleProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <article> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Article(vp, kids...)

}
func parseAside(n *html.Node) *react.AsideElem {

	var kids []react.Element

	var vp *react.AsideProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.AsideProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <aside> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Aside(vp, kids...)

}
func parseB(n *html.Node) *react.BElem {

	var kids []react.Element

	var vp *react.BProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.BProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <b> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.B(vp, kids...)

}
func parseBr(n *html.Node) *react.BrElem {

	var kids []react.Element

	var vp *react.BrProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.BrProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <br> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Br(vp, kids...)

}
func parseButton(n *html.Node) *react.ButtonElem {

	var kids []react.Element

	var vp *react.ButtonProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.ButtonProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case v == "type":
				vp.Type = a.Val

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <button> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Button(vp, kids...)

}
func parseCaption(n *html.Node) *react.CaptionElem {

	var kids []react.Element

	var vp *react.CaptionProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.CaptionProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <caption> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Caption(vp, kids...)

}
func parseCode(n *html.Node) *react.CodeElem {

	var kids []react.Element

	var vp *react.CodeProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.CodeProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <code> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Code(vp, kids...)

}
func parseDiv(n *html.Node) *react.DivElem {

	var kids []react.Element

	var vp *react.DivProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.DivProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <div> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Div(vp, kids...)

}
func parseEm(n *html.Node) *react.EmElem {

	var kids []react.Element

	var vp *react.EmProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.EmProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <em> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Em(vp, kids...)

}
func parseFooter(n *html.Node) *react.FooterElem {

	var kids []react.Element

	var vp *react.FooterProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.FooterProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <footer> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Footer(vp, kids...)

}
func parseForm(n *html.Node) *react.FormElem {

	var kids []react.Element

	var vp *react.FormProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.FormProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <form> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Form(vp, kids...)

}
func parseH1(n *html.Node) *react.H1Elem {

	var kids []react.Element

	var vp *react.H1Props
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.H1Props)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <h1> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.H1(vp, kids...)

}
func parseH2(n *html.Node) *react.H2Elem {

	var kids []react.Element

	var vp *react.H2Props
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.H2Props)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <h2> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.H2(vp, kids...)

}
func parseH3(n *html.Node) *react.H3Elem {

	var kids []react.Element

	var vp *react.H3Props
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.H3Props)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <h3> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.H3(vp, kids...)

}
func parseH4(n *html.Node) *react.H4Elem {

	var kids []react.Element

	var vp *react.H4Props
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.H4Props)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <h4> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.H4(vp, kids...)

}
func parseH5(n *html.Node) *react.H5Elem {

	var kids []react.Element

	var vp *react.H5Props
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.H5Props)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <h5> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.H5(vp, kids...)

}
func parseH6(n *html.Node) *react.H6Elem {

	var kids []react.Element

	var vp *react.H6Props
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.H6Props)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <h6> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.H6(vp, kids...)

}
func parseHeader(n *html.Node) *react.HeaderElem {

	var kids []react.Element

	var vp *react.HeaderProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.HeaderProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <header> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Header(vp, kids...)

}
func parseHr(n *html.Node) *react.HrElem {

	var vp *react.HrProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.HrProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <hr> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	return react.Hr(vp)

}
func parseI(n *html.Node) *react.IElem {

	var kids []react.Element

	var vp *react.IProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.IProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <i> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.I(vp, kids...)

}
func parseIFrame(n *html.Node) *react.IFrameElem {

	var kids []react.Element

	var vp *react.IFrameProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.IFrameProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "srcdoc":
				vp.SrcDoc = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <iframe> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.IFrame(vp, kids...)

}
func parseImg(n *html.Node) *react.ImgElem {

	var kids []react.Element

	var vp *react.ImgProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.ImgProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "alt":
				vp.Alt = a.Val

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "src":
				vp.Src = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <img> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Img(vp, kids...)

}
func parseInput(n *html.Node) *react.InputElem {

	var kids []react.Element

	var vp *react.InputProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.InputProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "placeholder":
				vp.Placeholder = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case v == "type":
				vp.Type = a.Val

			case v == "value":
				vp.Value = a.Val

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <input> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Input(vp, kids...)

}
func parseLabel(n *html.Node) *react.LabelElem {

	var kids []react.Element

	var vp *react.LabelProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.LabelProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "for":
				vp.For = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <label> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Label(vp, kids...)

}
func parseLi(n *html.Node) *react.LiElem {

	var kids []react.Element

	var vp *react.LiProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.LiProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <li> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Li(vp, kids...)

}
func parseMain(n *html.Node) *react.MainElem {

	var kids []react.Element

	var vp *react.MainProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.MainProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <main> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Main(vp, kids...)

}
func parseNav(n *html.Node) *react.NavElem {

	var kids []react.Element

	var vp *react.NavProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.NavProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <nav> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Nav(vp, kids...)

}
func parseOption(n *html.Node) *react.OptionElem {

	var kids []react.Element

	var vp *react.OptionProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.OptionProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case v == "value":
				vp.Value = a.Val

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <option> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Option(vp, kids...)

}
func parseP(n *html.Node) *react.PElem {

	var kids []react.Element

	var vp *react.PProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.PProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <p> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.P(vp, kids...)

}
func parsePre(n *html.Node) *react.PreElem {

	var kids []react.Element

	var vp *react.PreProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.PreProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <pre> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Pre(vp, kids...)

}
func parseSelect(n *html.Node) *react.SelectElem {

	var kids []*react.OptionElem

	var vp *react.SelectProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.SelectProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case v == "value":
				vp.Value = a.Val

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <select> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(*react.OptionElem))
	}

	return react.Select(vp, kids...)

}
func parseSpan(n *html.Node) *react.SpanElem {

	var kids []react.Element

	var vp *react.SpanProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.SpanProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <span> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Span(vp, kids...)

}
func parseStrike(n *html.Node) *react.StrikeElem {

	var kids []react.Element

	var vp *react.StrikeProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.StrikeProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <s> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Strike(vp, kids...)

}
func parseSup(n *html.Node) *react.SupElem {

	var kids []react.Element

	var vp *react.SupProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.SupProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <sup> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Sup(vp, kids...)

}
func parseTable(n *html.Node) *react.TableElem {

	var kids []react.Element

	var vp *react.TableProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.TableProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <table> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Table(vp, kids...)

}
func parseTbody(n *html.Node) *react.TbodyElem {

	var kids []react.Element

	var vp *react.TbodyProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.TbodyProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <tbody> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Tbody(vp, kids...)

}
func parseTd(n *html.Node) *react.TdElem {

	var kids []react.Element

	var vp *react.TdProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.TdProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <td> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Td(vp, kids...)

}
func parseTextArea(n *html.Node) *react.TextAreaElem {

	var kids []react.Element

	var vp *react.TextAreaProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.TextAreaProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "placeholder":
				vp.Placeholder = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case v == "value":
				vp.Value = a.Val

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <textarea> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.TextArea(vp, kids...)

}
func parseTh(n *html.Node) *react.ThElem {

	var kids []react.Element

	var vp *react.ThProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.ThProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <th> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Th(vp, kids...)

}
func parseThead(n *html.Node) *react.TheadElem {

	var kids []react.Element

	var vp *react.TheadProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.TheadProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <thead> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Thead(vp, kids...)

}
func parseTr(n *html.Node) *react.TrElem {

	var kids []react.Element

	var vp *react.TrProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.TrProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <tr> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.Element))
	}

	return react.Tr(vp, kids...)

}
func parseUl(n *html.Node) *react.UlElem {

	var kids []react.RendersLi

	var vp *react.UlProps
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.UlProps)

		for _, a := range n.Attr {
			switch v := a.Key; {

			case v == "aria-expanded":
				vp.AriaExpanded = parseBool(a.Val)

			case v == "aria-haspopup":
				vp.AriaHasPopup = parseBool(a.Val)

			case v == "aria-labelledby":
				vp.AriaLabelledBy = a.Val

			case v == "class":
				vp.ClassName = a.Val

			case v == "id":
				vp.ID = a.Val

			case v == "key":
				vp.Key = a.Val

			case v == "role":
				vp.Role = a.Val

			case v == "style":
				vp.Style = parseCSS(a.Val)

			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <ul> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).(react.RendersLi))
	}

	return react.Ul(vp, kids...)

}
