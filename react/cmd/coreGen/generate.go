// Copyright (c) 2016 Paul Jolly <paul@myitcv.org.uk>, all rights reserved.
// Use of this document is governed by a license found in the LICENSE document.

package main

import (
	"bytes"
	"go/ast"
	"go/format"
	"go/printer"
	"go/token"
	"io/ioutil"
	"path/filepath"
	"sort"
	"strings"
	"unicode/utf8"

	"myitcv.io/gogenerate"
)

const (
	reactPkg      = "myitcv.io/react"
	compDefName   = "ComponentDef"
	compDefSuffix = "Def"

	stateTypeSuffix     = "State"
	propsTypeSuffix     = "Props"
	propsTypeTmplPrefix = "_"

	getInitialState           = "GetInitialState"
	componentWillReceiveProps = "ComponentWillReceiveProps"
	equals                    = "Equals"
)

type typeFile struct {
	ts   *ast.TypeSpec
	file *ast.File
}

type funcFile struct {
	fn   *ast.FuncDecl
	file *ast.File
}

var fset = token.NewFileSet()

func astNodeString(i interface{}) string {
	b := bytes.NewBuffer(nil)
	err := printer.Fprint(b, fset, i)
	if err != nil {
		fatalf("failed to astNodeString %v: %v", i, err)
	}

	return b.String()
}

func lowerInitial(s string) string {
	if s == "" {
		return ""
	}

	r, w := utf8.DecodeRuneInString(s)
	return strings.ToLower(string(r)) + s[w:]
}

func dogen(dir, pkgName, license string) {
	cg := newCoreGen()

	// fill out templates
	for _, t := range templates {
		for n, a := range t {
			a.Name = n
			if a.React == "" {
				a.React = lowerInitial(n)
			}
			if a.HTML == "" {
				a.HTML = strings.ToLower(a.Name)
			}
			if a.HTMLConvert == "" && a.Type != "string" {
				switch a.Type {
				case "bool":
					a.HTMLConvert = "parseBool"
				}
			}
			if a.Type == "" {
				a.Type = "string"
			}
		}
	}

	// fill out elements
	for n, e := range elements {
		e.Name = n
		if e.React == "" {
			e.React = strings.ToLower(n)
		}
		if !e.NonHTML {
			e.Templates = append(e.Templates, "html")
		}
		if e.EmptyElement && (e.Child != "" || e.Children != "") {
			fatalf("element %v specified as EmptyElement but also child or children properties", e.Name)
		}
		if e.Child != "" && e.Children != "" {
			fatalf("element %v supplied both child and children properties", e.Name)
		}
		if !e.EmptyElement && e.Children == "" {
			e.Children = "Element"
		}
		if e.Dom == "" {
			e.Dom = "HTML" + e.Name + "Element"
		}
		if e.HTML == "" {
			e.HTML = strings.ToLower(e.Name)
		}
		for n, a := range e.Attributes {
			a.Name = n
			if a.React == "" {
				a.React = lowerInitial(n)
			}
			if a.HTML == "" {
				a.HTML = strings.ToLower(a.Name)
			}
			if a.HTMLConvert == "" && a.Type != "string" {
				switch a.Type {
				case "bool":
					a.HTMLConvert = "parseBool"
				}
			}
			if a.Type == "" {
				a.Type = "string"
			}
		}
	}

	var ens []string

	// generate elements
	for _, e := range elements {
		ens = append(ens, e.Name)
		attrs := make(map[string]*Attr)
		addAttr := func(n string, a *Attr) {
			if _, ok := attrs[n]; ok {
				fatalf("element %v had a clash for attribute %v", e.Name, n)
			}
			attrs[n] = a
		}

		for _, tn := range e.Templates {
			t, ok := templates[tn]
			if !ok {
				fatalf("element %v referenced non-existent template %q", e.Name, tn)
			}
			for _, a := range t {
				addAttr(a.Name, a)
			}
		}

		for _, a := range e.Attributes {
			addAttr(a.Name, a)
		}

		e.Attributes = attrs
	}

	sort.Strings(ens)

	// regular header
	cg.pf("// Code generated by %v. DO NOT EDIT.\n", coreGenCmd)
	cg.pln()
	cg.pf("package %v\n", pkgName)
	cg.pln()
	cg.pln(`import "github.com/gopherjs/gopherjs/js"`)

	// test header
	cg.tpln("// +build js")
	cg.tpln()
	cg.tpf("// Code generated by %v. DO NOT EDIT.\n", coreGenCmd)
	cg.tpln()
	cg.tpf("package %v_test\n", pkgName)
	cg.tpln(`
import (
	"testing"

	"honnef.co/go/js/dom"

	"myitcv.io/react"
	"myitcv.io/react/testutils"
)
	`)

	// jsx header
	cg.jpf("// Code generated by %v. DO NOT EDIT.\n", coreGenCmd)
	cg.jpln()
	cg.jpln("package jsx")
	cg.jpt(`
import (
	"fmt"
	"strings"

	"myitcv.io/react"

	"golang.org/x/net/html"
)

func parse(n *html.Node) react.Element {
	switch n.Type {
	case html.TextNode:
		return react.S(n.Data)
	case html.ElementNode:
		// we will fall out from here...
	default:
		panic(fmt.Errorf("cannot handle NodeType %v", n.Type))
	}

	switch n.Data {
	{{range .}}
	case "{{.React}}":
		return parse{{.Name}}(n)
	{{end}}
	default:
		panic(fmt.Errorf("cannot handle Element %v", n.Data))
	}
}
	`, elements)

	for _, en := range ens {
		e := elements[en]
		cg.pt(`
{{$elem := .}}

// {{.Name}}Elem is the React element definition corresponding to the HTML <{{.React}}> element
type {{.Name}}Elem struct {
	Element
}

func (a *{{.Name}}Elem) coreReactElement() {}

{{range .Implements}}
func (l *{{$elem.Name}}Elem) {{.}} {}
{{end}}

// {{.Name}}Props defines the properties for the <{{.React}}> element
type {{.Name}}Props struct {
	{{- range .Attributes}}
	{{.Name}} {{.Type -}}
	{{end}}
}

// {{.Name}} creates a new instance of a <{{.React}}> element with the provided props and
// children
func {{.Name}}(props *{{.Name}}Props, {{.ChildParam}}) *{{.Name}}Elem {
	type _{{.Name}}Props struct {
		o *js.Object
		{{- range .Attributes}}
		{{- if not .NoReact}}
		{{.Name}} {{.Type}} {{.Tag -}}
		{{end -}}
		{{end}}
	}

	{{.ChildConvert}}

	rprops := &_{{.Name}}Props{
		o: object.New(),
	}

	if props != nil {
		{{- range .Attributes}}
			{{- if eq .Name "Ref" }}
			if props.Ref != nil {
				rprops.o.Set("ref", props.Ref.Ref)
			}
			{{- else if eq .Name "DataSet" }}
			if props.DataSet != nil {
				for dk, dv := range props.DataSet {
					rprops.o.Set("data-"+dk, dv)
				}
			}
			{{- else if eq .Name "AriaSet" }}
			if props.AriaSet != nil {
				for dk, dv := range props.AriaSet {
					rprops.o.Set("aria-"+dk, dv)
				}
			}
			{{- else}}
			{{- if .OmitEmpty }}
				if props.{{.Name}} != "" {
					rprops.{{.Name}} = props.{{.Name}}
				}
			{{- else}}
			{{- if .IsEvent}}
				if props.{{.Name}} != nil {
					rprops.o.Set("{{.React}}", props.{{.Name}}.{{.Name}})
				}
			{{- else if eq .Name "Style"}}
				// TODO: until we have a resolution on
				// https://github.com/gopherjs/gopherjs/issues/236
				rprops.{{.Name}} = props.{{.Name}}.hack()
			{{- else}}
				rprops.{{.Name}} = props.{{.Name}}
			{{end -}}
			{{end -}}
			{{end -}}
		{{end -}}
	}

	return &{{.Name}}Elem{
		Element: createElement("{{.React}}", rprops, {{.ChildArg}}),
	}
}
		`, e)

		if !e.SkipTests {
			cg.tpt(`
func Test{{.Name}}Elem(t *testing.T) {
	class := "test"

	x := testutils.Wrapper(react.{{.Name}}(&react.{{.Name}}Props{ClassName: class}))
	cont := testutils.RenderIntoDocument(x)

	el := testutils.FindRenderedDOMComponentWithClass(cont, class)

	if _, ok := el.(*dom.{{.Dom}}); !ok {
		t.Fatal("Failed to find <{{.React}}> element")
	}
}
			`, e)
		}

		cg.jpt(`
func parse{{.Name}}(n *html.Node) *react.{{.Name}}Elem {
	{{if not .EmptyElement}}
	var kids []{{.ChildrenReactType}}
	{{end}}

	var vp *react.{{.Name}}Props
	var ds react.DataSet

	if len(n.Attr) > 0 {
		vp = new(react.{{.Name}}Props)

		for _, a := range n.Attr {
			switch v := a.Key; {
			{{range .HTMLAttributes}}
			case v == "{{.HTML}}":
				vp.{{.Name}} = {{.HTMLConvertor "a.Val"}}
			{{end}}
			case strings.HasPrefix(v, "data-"):
				if ds == nil {
					ds = make(react.DataSet)
				}
				ds[strings.TrimPrefix(v, "data-")] = a.Val
			default:
				panic(fmt.Errorf("don't know how to handle <{{.React}}> attribute %q", a.Key))
			}
		}

		vp.DataSet = ds
	}

	{{if not .EmptyElement}}
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		kids = append(kids, parse(c).({{.ChildrenReactType}}))
	}

	return react.{{.Name}}(vp, kids...)
	{{else}}
	return react.{{.Name}}(vp)
	{{end}}
}
		`, e)
	}

	write := func(w *bytes.Buffer, fn string) {
		toWrite := w.Bytes()

		out, err := format.Source(toWrite)
		if err == nil {
			toWrite = out
		}

		if err := ioutil.WriteFile(fn, toWrite, 0644); err != nil {
			fatalf("failed to write to %v; %v", fn, err)
		}
	}

	write(cg.buf, gogenerate.NameFile(pkgName, coreGenCmd))
	write(cg.tbuf, gogenerate.NameTestFile(pkgName, coreGenCmd))
	write(cg.jbuf, filepath.Join("jsx", gogenerate.NameFile("jsx", coreGenCmd)))
}
