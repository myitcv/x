package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"io/ioutil"
	"os/exec"
	"strings"

	"myitcv.io/gogenerate"
)

func (o *output) genImmTypes() {
	for f, v := range o.files {
		o.curFile = f

		if len(v.maps) == 0 && len(v.slices) == 0 && len(v.structs) == 0 {
			continue
		}

		o.output = bytes.NewBuffer(nil)

		o.pfln("// Code generated by %v. DO NOT EDIT.", immutableGenCmd)
		o.pln("")

		o.pf(o.license)

		o.pf("package %v\n", o.pkgName)

		// is there a "standard" place for //go:generate comments?
		for _, v := range o.goGenCmds {
			o.pf("//go:generate %v\n", v)
		}

		o.pln("//immutableVet:skipFile")
		o.pln("")

		o.pln("import (")

		o.pln("\"myitcv.io/immutable\"")
		o.pln()

		for i := range v.imports {
			if i.Name != nil {
				o.pfln("%v %v", i.Name.Name, i.Path.Value)
			} else {
				o.pfln("%v", i.Path.Value)
			}
		}

		o.pln(")")

		o.pln("")

		o.genImmMaps(v.maps)
		o.genImmSlices(v.slices)
		o.genImmStructs(v.structs)

		source := o.output.Bytes()

		toWrite := source

		fn := o.fset.Position(f.Pos()).Filename

		// this is the file path
		offn, ok := gogenerate.NameFileFromFile(fn, immutableGenCmd)
		if !ok {
			fatalf("could not name file from %v", fn)
		}

		out := bytes.NewBuffer(nil)
		cmd := exec.Command("gofmt", "-s")
		cmd.Stdin = o.output
		cmd.Stdout = out

		err := cmd.Run()
		if err == nil {
			toWrite = out.Bytes()
		} else {
			infof("failed to format %v: %v", fn, err)
		}

		if err := ioutil.WriteFile(offn, toWrite, 0644); err != nil {
			fatalf("could not write %v: %v", offn, err)
		}
	}
}

func (o *output) printImmPreamble(name string, node ast.Node) {
	fset := o.fset

	if st, ok := node.(*ast.StructType); ok {

		// we need to do some manipulation

		buf := bytes.NewBuffer(nil)

		fmt.Fprintf(buf, "struct {\n")

		if st.Fields != nil && st.Fields.NumFields() > 0 {
			line := o.fset.Position(st.Fields.List[0].Pos()).Line

			for _, f := range st.Fields.List {
				curLine := o.fset.Position(f.Pos()).Line

				if line != curLine {
					// catch up
					fmt.Fprintln(buf, "")
					line = curLine
				}

				ids := make([]string, 0, len(f.Names))
				for _, n := range f.Names {
					ids = append(ids, n.Name)
				}
				fmt.Fprintf(buf, "%v %v\n", strings.Join(ids, ","), o.exprString(f.Type))

				line++
			}
		}

		fmt.Fprintf(buf, "}")

		exprStr := buf.String()

		fset = token.NewFileSet()
		newnode, err := parser.ParseExprFrom(fset, "", exprStr, 0)
		if err != nil {
			fatalf("could not parse documentation struct from %v: %v", exprStr, err)
		}

		node = newnode
	}

	o.pln("//")
	o.pfln("// %v is an immutable type and has the following template:", name)
	o.pln("//")

	tmplBuf := bytes.NewBuffer(nil)

	err := printer.Fprint(tmplBuf, fset, node)
	if err != nil {
		fatalf("could not printer template declaration: %v", err)
	}

	sc := bufio.NewScanner(tmplBuf)
	for sc.Scan() {
		o.pfln("// \t%v", sc.Text())
	}
	if err := sc.Err(); err != nil {
		fatalf("could not scan printed template: %v", err)
	}

	o.pln("//")
}
